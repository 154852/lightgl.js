<!DOCTYPE html>
<html><body>
  <script src="../lightgl.js"></script>
  <script src="cessna.js"></script>
  <script>

var time = 0;
var angleX = 20;
var angleY = 20;
var gl = GL.create();
var mesh = GL.Mesh.load(cessna);
var sphere = GL.Mesh.sphere({ detail: 3 }).computeWireframe();
var plane = GL.Mesh.plane({ normals: true, coords: true }).transform(GL.Matrix.scale(300, 300, 1));
var depthMap = new GL.Texture(1024, 1024, { format: gl.RGB });
var texturePlane = GL.Mesh.plane({ coords: true });
var boundingSphere = mesh.getBoundingSphere();
var colorShader = new GL.Shader('\
  uniform vec3 center;\
  uniform float radius;\
  void main() {\
    gl_Position = gl_ModelViewProjectionMatrix * vec4(gl_Vertex.xyz * radius + center, 1.0);\
  }\
', '\
  void main() {\
    gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\
  }\
');
var depthShader = new GL.Shader('\
  varying vec4 pos;\
  void main() {\
    gl_Position = pos = gl_ModelViewProjectionMatrix * gl_Vertex;\
  }\
', '\
  varying vec4 pos;\
  void main() {\
    float depth = pos.z / pos.w;\
    gl_FragColor = vec4(depth * 0.5 + 0.5);\
  }\
');
var displayShader = new GL.Shader('\
  uniform mat4 shadowMapMatrix;\
  uniform vec3 light;\
  varying vec4 coord;\
  varying vec3 normal;\
  varying vec3 toLight;\
  void main() {\
    toLight = light - (gl_ModelViewMatrix * gl_Vertex).xyz;\
    normal = gl_NormalMatrix * gl_Normal;\
    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\
    coord = shadowMapMatrix * gl_Position;\
  }\
', '\
  uniform sampler2D depthMap;\
  varying vec4 coord;\
  varying vec3 normal;\
  varying vec3 toLight;\
  void main() {\
    float shadow = 0.0;\
    if (coord.w > 0.0) {\
      float depth = 0.0;\
      vec2 sample = coord.xy / coord.w * 0.5 + 0.5;\
      if (clamp(sample, 0.0, 1.0) == sample) {\
        float sampleDepth = texture2D(depthMap, sample).r;\
        depth = (sampleDepth == 1.0) ? 1.0e9 : sampleDepth;\
      }\
      if (depth > 0.0) {\
        float bias = -0.002;\
        shadow = clamp(300.0 * (bias + coord.z / coord.w * 0.5 + 0.5 - depth), 0.0, 1.0);\
      }\
    }\
    float ambient = 0.1;\
    float diffuse = max(0.0, dot(normalize(toLight), normalize(normal)));\
    gl_FragColor = vec4((normal * 0.5 + 0.5) * mix(ambient, 1.0, diffuse * (1.0 - shadow)), 1.0);\
  }\
');
var textureShader = new GL.Shader('\
  varying vec2 coord;\
  void main() {\
    coord = gl_TexCoord.xy;\
    gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);\
  }\
', '\
  uniform sampler2D texture;\
  varying vec2 coord;\
  void main() {\
    gl_FragColor = texture2D(texture, coord);\
  }\
');

gl.onupdate = function(seconds) {
  time += seconds;
};

gl.onmousemove = function(e) {
  if (e.dragging) {
    angleY += e.deltaX;
    angleX = Math.max(-90, Math.min(90, angleX + e.deltaY));
  }
};

gl.ondraw = function() {
  // Move the light around
  var light = new GL.Vector(100 * Math.sin(time * 0.2), 25, 20 * Math.cos(time * 0.2));

  // Construct a camera looking from the light toward the object. The view
  // frustum is fit so it tightly encloses the bounding sphere of the object,
  // to make best use of shadow map resolution. A frustum is a pyramid shape
  // with the apex chopped off.
  gl.matrixMode(gl.PROJECTION);
  gl.loadIdentity();
  var distance = boundingSphere.center.subtract(light).length();
  gl.perspective(180 - 2 * Math.acos(boundingSphere.radius / distance) * 180 / Math.PI, 1, distance - boundingSphere.radius, distance + boundingSphere.radius);
  gl.matrixMode(gl.MODELVIEW);
  gl.loadIdentity();
  gl.lookAt(light.x, light.y, light.z, boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, 0, 1, 0);

  // Render the object viewed from the light using a shader that returns the
  // fragment depth.
  var shadowMapMatrix = gl.projectionMatrix.multiply(gl.modelviewMatrix);
  depthMap.unbind();
  depthMap.drawTo(function() {
    gl.clearColor(1, 1, 1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    depthShader.draw(mesh);
  });

  // Recover the corners of the view frustum
  var w = gl.canvas.width, h = gl.canvas.height;
  var eye = gl.modelviewMatrix.inverse().transformPoint(new GL.Vector());
  var corners = [
    gl.unProject(0, 0, 0),
    gl.unProject(w, 0, 0),
    gl.unProject(0, h, 0),
    gl.unProject(w, h, 0),
    gl.unProject(0, 0, 1),
    gl.unProject(w, 0, 1),
    gl.unProject(0, h, 1),
    gl.unProject(w, h, 1)
  ];

  // Set up the camera for the scene
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.matrixMode(gl.PROJECTION);
  gl.loadIdentity();
  gl.perspective(45, gl.canvas.width / gl.canvas.height, 1, 1000);
  gl.matrixMode(gl.MODELVIEW);
  gl.loadIdentity();
  gl.translate(0, 0, -100);
  gl.rotate(angleX, 1, 0, 0);
  gl.rotate(angleY, 0, 1, 0);

  // Draw view frustum
  gl.pointSize(20);
  gl.begin(gl.LINES);
  for (var i = 0; i < 8; i++) {
    if (i < 4) {
      gl.color(1, 0, 0);
      gl.vertex(eye);
      gl.vertex(corners[i]);
    }
    gl.color(1, 1, 0);
    for (var j = 0; j < 3; j++) {
      gl.vertex(corners[i]);
      gl.vertex(corners[i ^ (1 << j)]);
    }
  }
  gl.end();

  // Draw bounding sphere
  colorShader.uniforms({
    center: boundingSphere.center,
    radius: boundingSphere.radius
  }).draw(sphere, gl.LINES);

  // Draw mesh
  depthMap.bind();
  displayShader.uniforms({
    shadowMapMatrix: shadowMapMatrix.multiply(gl.projectionMatrix.multiply(gl.modelviewMatrix).inverse()),
    light: gl.modelviewMatrix.transformPoint(light)
  }).draw(mesh);

  // Draw plane
  gl.pushMatrix();
  gl.rotate(-90, 1, 0, 0);
  displayShader.draw(plane);
  gl.popMatrix();

  // Draw depth map overlay
  gl.viewport(10, 10, 10 + 256, 10 + 256);
  textureShader.draw(texturePlane);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
};

gl.fullscreen();
gl.animate();
gl.enable(gl.DEPTH_TEST);

  </script>
</body></html>
