<script src="../lightgl.js"></script>
<script src="cessna.js"></script>
<script>

var mesh;
var plane;
var depthMap;
var depthShader;
var displayShader;
var angle = 0;

var texturePlane;
var textureShader;
var boundingSphere;

function setup() {
    document.body.appendChild(gl.canvas);
    gl.enable(gl.DEPTH_TEST);
    mesh = Mesh.load(cessna);
    boundingSphere = mesh.getBoundingSphere();
    plane = Mesh.plane(1, 1, { normals: true }).transform(Matrix.scale(300, 300, 300));
    depthMap = new Texture(1024, 1024, { format: gl.RGB });
    depthShader = new Shader('\
        varying vec4 pos;\
        void main() {\
            gl_Position = pos = gl_ModelViewProjectionMatrix * vec4(gl_Vertex, 1.0);\
        }\
    ', '\
        varying vec4 pos;\
        void main() {\
            float depth = pos.z / pos.w;\
            gl_FragColor = vec4(depth * 0.5 + 0.5);\
        }\
    ');
    displayShader = new Shader('\
        uniform mat4 shadowMapMatrix;\
        uniform vec3 light;\
        varying vec4 coord;\
        varying vec3 normal;\
        varying vec3 toLight;\
        void main() {\
            toLight = light - (gl_ModelViewMatrix * vec4(gl_Vertex, 1.0)).xyz;\
            normal = (gl_ModelViewMatrix * vec4(gl_Normal, 0.0)).xyz;\
            gl_Position = gl_ModelViewProjectionMatrix * vec4(gl_Vertex, 1.0);\
            coord = shadowMapMatrix * gl_Position;\
        }\
    ', '\
        uniform sampler2D depthMap;\
        varying vec4 coord;\
        varying vec3 normal;\
        varying vec3 toLight;\
        void main() {\
            float shadow = 0.0;\
            vec2 sample = coord.xy / coord.w * 0.5 + 0.5;\
            \
            /* Only take samples inside the texture */\
            if (coord.w > 0.0 && clamp(sample, 0.0, 1.0) == sample) {\
                /* Add a bias to avoid self-shadowing */\
                float bias = -0.002;\
                float depth = texture2D(depthMap, sample).r;\
                shadow = clamp(300.0 * (bias + coord.z / coord.w * 0.5 + 0.5 - depth), 0.0, 1.0);\
            }\
            \
            float ambient = 0.1;\
            float diffuse = max(0.0, dot(normalize(toLight), normalize(normal)));\
            gl_FragColor = vec4((normal * 0.5 + 0.5) * mix(ambient, 1.0, diffuse * (1.0 - shadow)), 1.0);\
        }\
    ');
    texturePlane = Mesh.plane(1, 1);
    textureShader = new Shader('\
        varying vec2 coord;\
        void main() {\
            coord = gl_TexCoord;\
            gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);\
        }\
    ', '\
        uniform sampler2D texture;\
        varying vec2 coord;\
        void main() {\
            gl_FragColor = texture2D(texture, coord);\
        }\
    ');
}

function update(seconds) {
    angle += 45 * seconds;
}

function draw() {
    var light = new Vector(100 * Math.sin(angle / 100), 25, 20 * Math.cos(angle / 100));

    // Fit a view frustum to the model's bounding sphere for the shadow map
    gl.matrixMode(gl.PROJECTION);
    gl.loadIdentity();
    var distance = boundingSphere.center.subtract(light).length();
    gl.perspective(180 - 2 * Math.acos(boundingSphere.radius / distance) * 180 / Math.PI, 1, distance - boundingSphere.radius, 1000);
    gl.matrixMode(gl.MODELVIEW);
    gl.loadIdentity();
    gl.lookAt(light.x, light.y, light.z, boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, 0, 1, 0);
    var shadowMapMatrix = gl.projectionMatrix.multiply(gl.modelviewMatrix);

    // Render into the shadow map
    depthMap.unbind();
    depthMap.drawTo(function() {
        gl.clearColor(1, 1, 1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        depthShader.draw(mesh);
    });
    depthMap.bind();

    // Render the shadow-mapped scene
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.matrixMode(gl.PROJECTION);
    gl.loadIdentity();
    gl.perspective(45, gl.canvas.width / gl.canvas.height, 1, 1000);
    gl.matrixMode(gl.MODELVIEW);
    gl.loadIdentity();
    gl.translate(0, 0, -100);
    gl.rotate(30, 1, 0, 0);
    gl.rotate(angle / 10, 0, 1, 0);
    shadowMapMatrix = shadowMapMatrix.multiply(gl.projectionMatrix.multiply(gl.modelviewMatrix).inverse());
    displayShader.uniforms({
        shadowMapMatrix: shadowMapMatrix,
        light: gl.modelviewMatrix.transformPoint(light)
    }).draw(mesh);
    gl.pushMatrix();
    gl.rotate(-90, 1, 0, 0);
    displayShader.draw(plane);
    gl.popMatrix();
    gl.begin(gl.LINES);
    gl.vertex(light.x, light.y, light.z);
    gl.end();

    // Render the depth map directly in the lower left
    gl.viewport(10, 10, 10 + 256, 10 + 256);
    textureShader.draw(texturePlane);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
}

</script>
